<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ControlFloor</title>

<link rel="stylesheet" href="https://cdn.materialdesignicons.com/4.9.95/css/materialdesignicons.min.css" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap" />
<link rel="stylesheet" href="/assets/css/styles.css" />
<link rel="stylesheet" href="/assets/css/sidebar.css" />
<link href="https://unpkg.com/@mountable/spinners@0.0.25/dist/mSpinnerSwirl.css" rel="stylesheet">

<meta charset="utf-8">
<style>
  canvas {
    border: solid 1px black;
  }
  .m-spinner--swirl {
    --spinner-color: red;
    --spinner-color-secondary: blue;
  }
  .hidden {
    display: none;
  }
  #back {
    font-size:64px;
    margin-right: 30px;
  }
  #under i {
    font-size:50px;
    cursor: pointer;
  }
  #d_name, #d_model, #d_iosversion, #d_udid {
    white-space: nowrap;
  }
  .note {
    padding: 10px;
    margin: 5px;
    background-color: #e8e7b0;
  }
  .notedet {
    padding: 10px;
    margin: 5px;
  }
  .detholder {
    position: absolute;
    margin-left: 20px;
    border: solid 2px blue;
    height: 200px;
    width: 400px;
    background-color: #e8e7b0;
  }
  #shutdown {
    font-size:40px;
    cursor: pointer;
  }
  #shutdown:hover:after {
    font-size: 12pt;
    content: "Reset device provision. Clicking this will reset the device control and video. If the device is not responding to clicking or video is not shown click this to reset. It will take around 30 seconds to reset.";
    display: block;
    position: relative;
    top: 0px;
    left: 40px;
    width: 300px;
    padding: 10px;
    background: #e8e7b0;
    border: solid 2px blue;
  }
</style>
<script>
  function getel( id ) {
    return document.getElementById( id );
  }
  function ntext( text ) {
    return document.createTextNode( text );
  }
  function ndiv() {
    return document.createElement("div");
  }
  function filltext( id, text ) {
    var parent = getel(id);
    var node = ntext( text );
    parent.appendChild( node );
  }
  function getCursorPosition(canvas, event) {
    const rect = canvas.getBoundingClientRect()
    const x = event.clientX - rect.left
    const y = event.clientY - rect.top
    console.log("x: " + x + " y: " + y)
    return [x,y];
  }
  var session='';
  var udid="{{ html .udid }}";
  var clickWid={{ html .clickWidth }}*1;
  var clickHeg={{ html .clickHeight }}*1;
  var vidWid={{ html .vidWidth }}*1;
  var vidHeg={{ html .vidHeight }}*1;
  var maxHeg={{ html .maxHeight }}*1;
  var displayWid=0;
  var displayHeg=0;
  var base = document.location.protocol + '//' + document.location.host;
  var gone = 0;
  var rid="{{ html .rid }}";
  var idleTimeout = "{{ html .idleTimeout }}" * 1;
  var keyid = 0;
  var mouseDownDate;
  var mouseUpDate;
  var info = JSON.parse( {{ html .rawInfo }} );
  var notestext = {{ html .notes }};
  var notesjson = JSON.parse( notestext );
  
  if( vidHeg < maxHeg ) {
    displayHeg = vidHeg;
    displayWid = vidWid;
  } else {
    var wOverH = vidWid / vidHeg;
    displayHeg = maxHeg;
    displayWid = maxHeg * wOverH;
  }
  function req( type, url, handler, body ) {
    var xhr = new XMLHttpRequest();
    xhr.open( type, url, true );
    xhr.responseType = 'json';
    xhr.onload = function(x) { handler(x,xhr); }
    if( type == 'POST' && body ) {
        if( typeof( body ) == 'object' ) {
            var data = new FormData();
            var test = {};
            for( var k in body ) if( body.hasOwnProperty( k ) ) { data.append( k, body[k] ); test[k] = body[k]; }
            console.log( test );
            xhr.send( data );
        }
        else xhr.send(body);
    }
    else xhr.send();
  }
  
  var waitnum = 0;
  function wait() {
    if( !waitnum ) {
      var waiter = getel("waiter");
      waiter.className = "m-spinner--swirl";
    }
    waitnum++;
  }
  function unwait() {
    if( waitnum > 0 ) waitnum--;
    if( !waitnum ) {
      var waiter = getel("waiter");
      waiter.className = "m-spinner--swirl hidden";
    }
  }
  
  function clickAt( pos ) {
    var x = Math.floor( (pos[0]/displayWid)*clickWid ); 
    var y = Math.floor( (pos[1]/displayHeg)*clickHeg );
    wait();
    req( 'POST', base + '/device/click', function() {
      unwait();
    }, { udid, x, y } );
  }
  function doHardPress( pos ) {
    var x = Math.floor( (pos[0]/displayWid)*clickWid ); 
    var y = Math.floor( (pos[1]/displayHeg)*clickHeg );
    wait();
    req( 'POST', base + '/device/hardPress', function() {
      unwait();
    }, { udid, x, y } );
  }
  function doLongPress( pos ) {
    var x = Math.floor( (pos[0]/displayWid)*clickWid ); 
    var y = Math.floor( (pos[1]/displayHeg)*clickHeg );
    wait();
    req( 'POST', base + '/device/longPress', function() {
      unwait();
    }, { udid, x, y } );
  }
  function swipe( pos1, pos2, delay ) {
    var x1 = Math.floor( (pos1[0]/displayWid)*clickWid ); 
    var y1 = Math.floor( (pos1[1]/displayHeg)*clickHeg );
    var x2 = Math.floor( (pos2[0]/displayWid)*clickWid ); 
    var y2 = Math.floor( (pos2[1]/displayHeg)*clickHeg );
    wait();
    req( 'POST', base + '/device/swipe', function() {
      unwait();
    }, { udid, x1, y1, x2, y2, delay } );    
  }
  function doShutdown() {
    wait();
    req( 'POST', base + '/device/shutdown', function() {
      unwait();
      location.reload();
    }, { udid } );    
  }
  function videoStop() {
    req( 'POST', base + "/device/videoStop?udid="+udid+"&rid="+rid, function() {}, {} );    
  }
  var keyqueue = [];
  var prevKeys = [];
  var inRequest = 0;
  var pos1;
  /*
  sendKeys has been hacked up a bunch since it was originally written.
  Right now it is sending a single key at a time and waiting for that
  call to complete before sending another key.
  
  This is done to prevent concurrency from causing keys to be entered
  out of typing order.
  
  There is additional information being sent that is not needed currently
  that could be used to be extremely sure keys are never sent out of order.
  
  This function can still be improved some more, as if keys are backed up
  and waiting to be sent we could send more than a single key at once.
  
  The backend doesn't handle doing that as well as desierd so that is
  avoided currently.
  */
  function sendKeys() {
    if( !keyqueue.length || inRequest ) return;
    //var keys = keyqueue.join("");
    var keyOb = keyqueue.shift();
    
    //keyqueue = [];
    inRequest = 1;
    wait();
    req( 'POST', base + '/device/keys', function() {
      unwait();
      inRequest = 0;
      if( keyqueue.length ) sendKeys();
    }, {
      udid: udid,
      keys: keyOb.keycode,
      curid: keyOb.keyid,
      prevkeys: prevKeys.join("")
    } );
    prevKeys.unshift( keyOb.keyid );
    while( prevKeys.length > 5 ) prevKeys.pop();
  }
  
  var mode = 'normal';
  var capture  = {}; // onkeydown
  var capture2 = {}; // onkeypress
  capture[-8] = -8; // backspace
  capture[-9] = -9; // tab
  capture[-13] = -13; // enter
  capture[-34] = -34; // pagedown
  capture[-33] = -33; // pageup
  capture[-35] = -35; // end
  capture[-36] = -36; // home
  capture[-37] = -37; // left
  capture[-38] = -38; // up
  capture[-39] = -39; // right
  capture[-40] = -40; // down
  capture[-46] = -46; // delete
  
  //capture[68] = 68; // delete; map to ascii delete
  capture2[39] = 39; // ' - quick search in firefox
  capture2[47] = 47; // / - quick search also
  window.addEventListener("load", function(evt) {
    filltext( "d_name", info.DeviceName );
    filltext( "d_model", info.ArtworkDeviceProductDescription );
    filltext( "d_iosversion", info.ProductVersion );
    filltext( "d_udid", info.UniqueDeviceID );
  
    var canvas    = getel("canvas");
    var ctx       = canvas.getContext("2d", { alpha: false });
    var home      = getel("home");
    var hardPress = getel("hardPress");
    var longPress = getel("longPress");
    var under     = getel("under");
    var vidbox    = getel("vidbox");
    var ws;
    var loading   = getel("loading");
    var notesbox  = getel("notes");
    var shutdown  = getel("shutdown");
    var sizes = [];
    var times = [];
    
    var ties = {};
    for( var i=0; i<notesjson.length; i++ ) {
      var anote = notesjson[i];
      var notediv = ndiv();
      notediv.className = "note";
      //var notetext = ntext( anote.short );
      //notediv.appendChild( notetext );
      notediv.innerHTML = anote.short;
      
      var detholder = ndiv();
      detholder.className = "detholder hidden";
      
      var notedetail = ndiv();
      notedetail.className = "notedet";
      var notedetailtext = ntext( anote.long );
      notedetail.appendChild( notedetailtext );
      detholder.appendChild( notedetail );
      
      var mouseover = notediv.onmouseover = function() {
        this.detail.className = "detholder" 
      }.bind(anote)
      
      var mouseout = notediv.onmouseout = function() {
        this.detail.className = "detholder hidden";
      }.bind(anote)
      
      anote.detail = detholder;
      
      notesbox.appendChild( notediv );
      notesbox.appendChild( detholder );
      
      if( anote.tie ) {
        ties[anote.tie] = {
          mouseover: mouseover,
          mouseout: mouseout
        }
      }
    }
    
    var idleSeconds = 0;
    
    //vidbox.style.width  = ( displayWid + 100 ) + "px";
    canvas.width      = displayWid;
    canvas.height     = displayHeg;
    getel("mid").style.width = displayWid + "px";
    under.style.top = displayHeg + "px";
    under.style.width = displayWid + "px";
    //loading.style.left = ( displayWid / 2 -50 ) + "px";
    //loading.style.top = ( displayHeg / 2 - 50 ) + "px";
    
    home.onclick = function( event ) {
      wait();
      req( 'POST', '/device/home', function() {
        unwait();
      }, { udid } );  
    }
    hardPress.onclick = function( event ) {
      if( mode != 'hard' ) {
        hardPress.className = 'mdi mdi-anvil mActive';
        longPress.className = 'mdi mdi-alarm-multiple mInactive';
        mode = 'hard';
      } else {
        hardPress.className = 'mdi mdi-anvil mInactive';
        mode = 'normal';
      }
    }
    if( ties["hardpress"] ) {
      var det = ties["hardpress"];
      hardPress.onmouseover = det.mouseover;
      hardPress.onmouseout = det.mouseout;
    }
    longPress.onclick = function( event ) {
      if( mode != 'long' ) {
        longPress.className = 'mdi mdi-alarm-multiple mActive';
        hardPress.className = 'mdi mdi-anvil mInactive';
        mode = 'long';
      } else {
        longPress.className = 'mdi mdi-alarm-multiple mInactive';
        mode = 'normal';
      }
    }
    shutdown.onclick = function( event ) {
      var ok = confirm("This will shutdown/reset the device provider. Are you sure?");
      if( ok ) {
        videoStop();
        if( ws ) ws.close();
        doShutdown();
      }
    }
    if( ties["longpress"] ) {
      var det = ties["longpress"];
      longPress.onmouseover = det.mouseover;
      longPress.onmouseout = det.mouseout;
    }
    
    canvas.onmousedown = function( event ) {
      mouseDownDate = new Date();
      var pos = getCursorPosition( canvas, event );
      if     ( mode == 'hard' ) doHardPress( pos );
      else if( mode == 'long' ) doLongPress( pos );
      else                      pos1 = pos;
    }
    
    canvas.onmouseup = function( event ) {
      if( mode != 'normal' ) return;
      mouseUpDate = new Date();
      var msDiff = mouseUpDate - mouseDownDate;
      var sDiff = msDiff / 1000;
      sDiff = Math.floor( sDiff * 100 ) / 100; // .00 resolution
      var pos2 = getCursorPosition( canvas, event );
      var dx = Math.abs( pos2[0] - pos1[0] );
      var dy = Math.abs( pos2[1] - pos1[1] );
      if( dx > 3 || dy > 3 ) {
        swipe( pos1, pos2, sDiff );
      }
      else clickAt( pos1 );
    }
    
    window.onkeydown = function( event ) {
      var key = event.key;
      if( key == "Shift" ) return;
      if( key.length==1 ) key = key.charCodeAt(0);
      else key = -event.keyCode;
      
      if( capture[ key ] ) {
        key = capture[ key ];
        event.preventDefault();
        keyqueue.push( {
          keycode: key,
          keyid: keyid
        } );
        keyid++;
        sendKeys();
      }
      else console.log( "key " + key );
    }
    
    window.onkeypress = function( event ) {
      var key = event.key;
      
      if( key.length==1 ) key = key.charCodeAt(0);
      else key = -event.keyCode;
      
      keyqueue.push( {
        keycode: key,
        keyid: keyid
      } );
      keyid++;
      sendKeys();
      if( capture2[ key ] ) {
        event.preventDefault();
      } else console.log( "key2 " + key );
    }
    
    var wsprot = ( document.location.protocol == 'https:' ) ? "wss" : "ws"; 
    var url = wsprot+"://"+document.location.host+"/device/imgStream?udid={{ html .udid }}&rid={{ html .rid }}";
    ws = new WebSocket( url );
    ws.onopen = function( event ) {
        console.log("Websocket open");
    }
    ws.onclose = function( event ) {
        console.log("Websocket closed");
        ws = null;
    }
    ws.onmessage = function( event ) {
        if( event.data instanceof Blob ) {
          var recvTime = new Date().getTime();
          var image = new Image();
          var url;
          image.onload = function() {
            URL.revokeObjectURL( url );
            ctx.drawImage(image, 0, 0, Math.floor(displayWid)+1, Math.floor(displayHeg) );
          };
          image.onerror = function( e ) {
            console.log('Error during loading image:', e);
          }
          var blob = event.data;
          var imgData = blob.slice( 0, -100, "image/jpeg" );
          blob.slice( -100, blob.size, "" ).text().then( serverTimeStr => {
              //console.log( "serverTimeStr " + serverTimeStr );
              var serverTime = parseInt( serverTimeStr );
              var diff = recvTime - serverTime;
              if( diff < 0 ) diff = 0;
              //console.log( recvTime + " - " + serverTime + " = " + diff );
              
              //var bpms = (blob.size-100) / diff;
              //var bps = bpms * 1000;
              //console.log( "bps " + bps );
              sizes.push( blob.size );
              times.push( diff );
              if( sizes.length == 5 ) {
                  var totSize = 0;
                  var totTime = 0;
                  for( var i=0;i<5;i++ ) {
                      totSize += sizes[i];
                      totTime += times[i];
                  }
                  var bps = Math.floor( totSize / totTime * 1000 );
                  if( bps > 10000000 ) {
                      bps = 10000000;
                  }
                  console.log("bps " + bps);
                  sizes = [];
                  times = [];
                  var avgFrame = Math.floor( totSize / 5 );
                  ws.send( "{\"bps\":\"" + bps + "\",\"avgFrame\":\"" + avgFrame + "\"}" );
              }
          } );
          
          url = URL.createObjectURL( blob );
          image.src = url;
        }
        else {
            var data = event.data;
            if( typeof data === 'string' ) {
                var recvTime = new Date().getTime();
                var l1 = data[0];
                if( l1 >= '0' && l1 <= '9' ) {
                    var serverTime = parseInt( data );
                    var diff = recvTime - serverTime;
                    console.log( "latency:" + diff );
                }
                else if( l1 == '{' ) {
                    var json = JSON.parse( data );
                    var type = json.type;
                    if( type ) {
                        if( type == 'kick' ) {
                            alert("You have been kicked");
                            document.location.href = "/";
                        }
                        if( type == 'sync' ) {
                            var serverTime = json.serverTime;
                            //console.log( "serverTime is " + serverTime );
                            var ourTime = Date.now();//new Date().getTime();
                            //console.log( "ourTime is " + ourTime );
                            
                            var diff = ourTime - serverTime;
                            
                            ws.send( "{\"clientTime\":\"" + ourTime + "\",\"sentTime\":\"" + serverTime + "\"}" );
                            
                            console.log( "latency + time offset = " + diff );
                        }
                    }
                } else {
                    var parts = data.split(',');
                    if( parts[0] == 'sync' ) {
                        var serverTime = parts[1];
                        var ourTime = Date.now();//new Date().getTime();
                        var diff = ourTime - serverTime;
                            
                        ws.send( "{\"clientTime\":\"" + ourTime + "\",\"sentTime\":\"" + serverTime + "\"}" );
                        
                        console.log( "latency + time offset = " + diff );
                    }
                }
            }
            //console.log( event.data );
        }
    }
    ws.onerror = function( event ) {
        console.log( "Error: ", event.data );
    }
    if( idleTimeout ) {
      setInterval( function() {
        idleSeconds += 3;
        if( idleSeconds > idleTimeout ) {
          ws.close();
          navigator.sendBeacon( "/device/videoStop?udid="+udid+"&rid="+rid, "" );
          alert("Inactivity timeout");
          document.location.href = '/';
        }
      }, 3000 );
      window.onmousemove = function() {
        idleSeconds = 0;
      }
    }
  });
</script>
<script defer src="/assets/js/lifecycle.es5.js"></script>
<script defer>
  setTimeout( function() {
    lifecycle.addEventListener('statechange', function( event ) {
      // Despite information online saying this should work with visibilitychange; it does not
      if( !gone && /*event.originalEvent == 'visibilitychange' && */event.newState == 'hidden' ) {
        gone = 1;
        console.log("Sending beacon for udid " + udid );
        navigator.sendBeacon( "/device/videoStop?udid="+udid+"&rid="+rid, "" );
      }
    } );
  }, 1000 );
</script>

</head>

<body>
    <div id="main" class="main">
        <div>
            <table style="margin:auto; position: relative;"><tr>
                <td valign="top" style="display:none">
                    <div style="display: inline-block">
                        <a href='/'><i id='back' class="mdi mdi-arrow-left-bold"></i></a>
                    </div>
                </td>
                <td style="position:relative" id="mid">
                    <!--<i id="loading" style="vertical-align: top; position: absolute; left:100px; top:100px; font-size:100px;" class="m-spinner--swirl"></i>-->
                    <canvas id="canvas" width="375" height="667" style="position:absolute; top:0px; left:0px;"></canvas><br>
                    <div style="display:none; position: absolute; width:375px; font-size: 32px" id="under">
                        <center>
                            <i id='home' class="mdi mdi-home"></i>
                            <i id='hardPress' class="mdi mdi-anvil mInactive"></i>
                            <i id='longPress' class="mdi mdi-alarm-multiple mInactive"></i>
                        </i>
                    </div>
                </td>
                <td valign="top" style="padding: 15px; display:none">
                    <table cellpadding=10 cellspacing=0>
                        <tr>
                            <td>Name</td>
                            <td id="d_name"></td>
                        </tr>
                        <tr>
                            <td>Model</td>
                            <td id="d_model"></td>
                        </tr>
                        <tr>
                            <td><nobr>iOS Version</nobr></td>
                            <td id="d_iosversion"></td>
                        </tr>
                        <tr>
                            <td><nobr>UDID</nobr></td>
                            <td id="d_udid"></td>
                        </tr>
                        <tr><td colspan=2 id="notes"></td></tr>
                        <tr><td colspan=2>
                          <i id='shutdown' class="mdi mdi-bomb"></i>
                        </tr></tr>
                        <tr>
                          <td colspan=2>
                            <i id="waiter" style="vertical-align: top" class="hidden m-spinner--swirl"></i>
                          </td>
                        </td>
                    </table>
                </td>
            </tr></table>
        </div>
    </div>
</body>
</html>
