<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ControlFloor</title>

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap" />
<link rel="stylesheet" href="/assets/css/styles.css" />
<link rel="stylesheet" href="/assets/css/sidebar.css" />
<link href="https://unpkg.com/@mountable/spinners@0.0.25/dist/mSpinnerSwirl.css" rel="stylesheet">
<script src="/assets/js/iconify_icons.js"></script>

<meta charset="utf-8">
<style>
  canvas {
    border: solid 1px black;
  }
  .m-spinner--swirl {
    --spinner-color: red;
    --spinner-color-secondary: blue;
  }
  .hidden {
    display: none;
  }
  #back {
    font-size:64px;
    margin-right: 30px;
  }
  #under svg {
    position: relative;
    top: 10px;
    font-size:50px;
    cursor: pointer;
  }
  #d_name, #d_model, #d_iosversion, #d_udid {
    white-space: nowrap;
  }
  .note {
    padding: 10px;
    margin: 5px;
    background-color: #e8e7b0;
  }
  .notedet {
    padding: 10px;
    margin: 5px;
  }
  .detholder {
    position: absolute;
    margin-left: 20px;
    border: solid 2px blue;
    height: 200px;
    width: 400px;
    background-color: #e8e7b0;
  }
  #shutdown {
    font-size:40px;
    cursor: pointer;
  }
  #shutdown:hover:after {
    font-size: 12pt;
    content: "Reset device provision. Clicking this will reset the device control and video. If the device is not responding to clicking or video is not shown click this to reset. It will take around 30 seconds to reset.";
    display: block;
    position: relative;
    top: 0px;
    left: 40px;
    width: 300px;
    padding: 10px;
    background: #e8e7b0;
    border: solid 2px blue;
  }
  #ta {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 375px;
    height: 667px;
    z-index: 2;
    background: transparent;
    border: none;
    resize: none;
    caret-color: transparent;
    cursor: pointer;
    color: rgba(0,0,0,0);
  }
</style>
<script>
  // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values
  var specialKeys = {
    "Backspace" : 1,
   // "Enter"     : 1, //Captured with regular text, \n, \t
   // "Tab"       : 1,
    "Escape"    : 1,
    "ArrowUp"   : 1,
    "ArrowDown" : 1,
    "ArrowLeft" : 1,
    "ArrowRight": 1,
    "PageDown"  : 1,
    "PageUp"    : 1,
    "End"       : 1,
    "Home"      : 1,
    "Delete"      : 1,
   // "F1"  : 1,  //Uncomment to send to device 
   // "F2"  : 1,
   // "F3"  : 1,
   // "F4"  : 1,
   // "F5"  : 1,
   // "F6"  : 1,
   // "F7"  : 1,
   // "F8"  : 1,
   // "F9"  : 1,
   // "F10" : 1,
   // "F11" : 1,
   // "F12" : 1,
  };

  function getel( id ) {
    return document.getElementById( id );
  }
  function ntext( text ) {
    return document.createTextNode( text );
  }
  function ndiv() {
    return document.createElement("div");
  }
  function filltext( id, text ) {
    var parent = getel(id);
    var node = ntext( text );
    parent.appendChild( node );
  }
  function getEventCoordinatesOnCanvas(canvas, event) {
    const rect = canvas.getBoundingClientRect()
    const x = event.clientX - rect.left
    const y = event.clientY - rect.top
    console.log("x: " + x + " y: " + y)
    return [x,y];
  } 
  function getEventCoordinatesOnDevice(canvas, event) {
    let [x,y] = getEventCoordinatesOnCanvas(canvas,event);
    x = Math.floor( x*clickWid/displayWid );
    y = Math.floor( y*clickHeg/displayHeg );
    return [x,y];
  }
  function sendCFRequest(action,args){
      let request = {action:action,tag:sequenceNumber,args:args}
      sequenceNumber++;
      wait();
      commandSocket.send(JSON.stringify(request));
  }
  function sendTapOrClickCFRequest(canvas, event, action, args = {}){
      let [x,y] = getEventCoordinatesOnDevice(canvas,event);
      args['x'] = x;
      args['y'] = y;
      sendCFRequest(action,args);
  }
  function _replace(node,rep) {
    node.parentNode.replaceChild(rep,node);
  }
  function loadIcons() {
    var icons = document.getElementsByClassName("iconify");
    var dp = new DOMParser();
    for( var i=0;i<icons.length;i++ ) {
    //while( icons.length ) {
      var icon = icons[i];
      var id = icon.id;
      var cls = icon.className;
      var mdiName = icon.dataset.icon;
      var width = 40;
      var height = 40;
      var svgText = "<div style='display:inline-block; width:"+width+"px; height:"+height+"px;'>"+
        "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">" +
        iconify_icons[ mdiName ] + "</svg></div>";
      var frag = dp.parseFromString( svgText, "text/html" ).body.childNodes[0];
      _replace( icon, frag );
      frag.id = id;
      frag.className = cls;
    }
  }
  var session='';
  var udid="{{ html .udid }}";
  var clickWid={{ html .clickWidth }}*1;
  var clickHeg={{ html .clickHeight }}*1;
  var originalClickWid={{ html .clickWidth }}*1;
  var originalClickHeg={{ html .clickHeight }}*1;
  var vidWid={{ html .vidWidth }}*1;
  var vidHeg={{ html .vidHeight }}*1;
  var maxHeg={{ html .maxHeight }}*1;
  var orientation={{ html .orientation }};
  var originalDisplayWid=0;
  var originalDisplayHeg=0;
  var displayWid=0;
  var displayHeg=0;
  var base = document.location.protocol + '//' + document.location.host;
  var gone = 0;
  var rid="{{ html .rid }}";
  var idleTimeout = "{{ html .idleTimeout }}" * 1;
  var sequenceNumber = 1;
  var mouseUpDate;
  var info = JSON.parse( {{ html .rawInfo }} );
  var notestext = {{ html .notes }};
  var notesjson = JSON.parse( notestext );
  var commandSocket = null;
  var mouseDownEvent; //used for longpress long press tapTime decisions
  var mouseDownDate;  //used to time long presses
  
  if( vidHeg < maxHeg ) {
    displayHeg = vidHeg;
    displayWid = vidWid;
  } else {
    var wOverH = vidWid / vidHeg;
    displayHeg = maxHeg;
    displayWid = maxHeg * wOverH;
  }
  originalDisplayWid = displayWid;
  originalDisplayHeg = displayHeg;
  
  function req( type, url, handler, body ) {
    var xhr = new XMLHttpRequest();
    xhr.open( type, url, true );
    xhr.responseType = 'json';
    xhr.onload = function(x) { handler(x,xhr); }
    if( type == 'POST' && body ) {
        if( typeof( body ) == 'object' ) {
            var data = new FormData();
            var test = {};
            for( var k in body ) if( body.hasOwnProperty( k ) ) { data.append( k, body[k] ); test[k] = body[k]; }
            console.log( test );
            xhr.send( data );
        }
        else xhr.send(body);
    }
    else xhr.send();
  }
  
  setTimeout( function() {
      ta.value = "";
  }, 10 );

  var waitTimeout = null;
  function activateSpinner(){
      var waiter = getel("waiter");
      waiter.className = "m-spinner--swirl";
      waitTimeout = null;
  }
  var waitnum = 0;
  function wait() {
    if( !waitnum ) {
        if(!waitTimeout){
            waitTimeout = setTimeout(activateSpinner,1000);
        }
    }
    waitnum++;
  }
  function unwait() {
    if( waitnum > 0 ) waitnum--;
    if( !waitnum ) {
      var waiter = getel("waiter");
      waiter.className = "m-spinner--swirl hidden";
      if(waitTimeout){
          clearTimeout(waitTimeout);
      }
    }
  }
  
  function doShutdown() {
    wait();
    req( 'POST', base + '/device/shutdown', function() {
      unwait();
      location.reload();
    }, { udid } );    
  }
  function videoStop() {
    req( 'POST', base + "/device/videoStop?udid="+udid+"&rid="+rid, function() {}, {} );    
  }
  var keyqueue = [];
  var prevKeys = [];
  var inRequest = 0;

  function sendText( text ) {
    sendCFRequest("typeText",{
        "text":text
    });
  }
  
  function setOrientation( o ) {
      var newWid = originalDisplayWid;
      var newHeg = originalDisplayHeg;
      var newClickWid = originalClickWid;
      var newClickHeg = originalClickHeg;
      switch( o ) {
          case "landscapeLeft":
              newWid = originalDisplayHeg;
              newHeg = originalDisplayWid;
              newClickWid = originalClickHeg;
              newClickHeg = originalDisplayWid;
              break;
          case "landscapeRight":
              newWid = originalDisplayHeg;
              newHeg = originalDisplayWid;
              newClickWid = originalClickHeg;
              newClickHeg = originalDisplayWid;
              break;
      }
      
      displayWid = newWid;
      displayHeg = newHeg;
      clickWid = newClickWid;
      clickHeg = newClickHeg;
      canvas.width      = newWid;
      canvas.height     = newHeg;
      ta.style.width = newWid + "px";
      ta.style.height = newHeg + "px";
      getel("mid").style.width = newWid + "px";
      under.style.top = newHeg + "px";
      under.style.width = newWid + "px";
  }
  
  var mode = 'normal';
  var capture2 = {}; // onkeypress
  
  //capture[68] = 68; // delete; map to ascii delete
  capture2[39] = 39; // ' - quick search in firefox
  capture2[47] = 47; // / - quick search also
  window.addEventListener("load", function(evt) {
    loadIcons();
    filltext( "d_name", info.DeviceName );
    filltext( "d_model", info.ArtworkDeviceProductDescription );
    filltext( "d_iosversion", info.ProductVersion );
    filltext( "d_udid", info.UniqueDeviceID );
  
    var canvas    = getel("canvas");
    var ctx       = canvas.getContext("2d", { alpha: false });
    var home      = getel("home");
    //var taskBtn   = getel("taskBtn");
    //var shakeBtn  = getel("shakeBtn");
    var ccBtn     = getel("ccBtn");
    var atBtn     = getel("atBtn");
    var hardPress = getel("hardPress");
    //var longPress = getel("longPress");
    //var vectorBtn = getel("vectorBtn");
    var under     = getel("under");
    var vidbox    = getel("vidbox");
    var videoSocket;
    var loading   = getel("loading");
    var notesbox  = getel("notes");
    var shutdown  = getel("shutdown");
    var ta        = getel("ta");
    var sizes = [];
    var times = [];

    hardPress.childNodes[0].setAttribute("fill","");
    //longPress.childNodes[0].setAttribute("fill","");
    //vectorBtn.childNodes[0].setAttribute("fill","");
    
    var ties = {};
    for( var i=0; i<notesjson.length; i++ ) {
      var anote = notesjson[i];
      var notediv = ndiv();
      notediv.className = "note";
      //var notetext = ntext( anote.short );
      //notediv.appendChild( notetext );
      notediv.innerHTML = anote.short;
      
      var detholder = ndiv();
      detholder.className = "detholder hidden";
      
      var notedetail = ndiv();
      notedetail.className = "notedet";
      var notedetailtext = ntext( anote.long );
      notedetail.appendChild( notedetailtext );
      detholder.appendChild( notedetail );
      
      var mouseover = notediv.onmouseover = function() {
        this.detail.className = "detholder" 
      }.bind(anote)
      
      var mouseout = notediv.onmouseout = function() {
        this.detail.className = "detholder hidden";
      }.bind(anote)
      
      anote.detail = detholder;
      
      notesbox.appendChild( notediv );
      notesbox.appendChild( detholder );
      
      if( anote.tie ) {
        ties[anote.tie] = {
          mouseover: mouseover,
          mouseout: mouseout
        }
      }
    }
    
    var idleSeconds = 0;
    
    setOrientation( orientation );
    
    home.onclick = function( event ) {
      sendCFRequest("simulateHomeButton",{});
    }
    /*taskBtn.onclick = function( event ) {
      wait();
      req( 'POST', '/device/taskSwitcher', function() {
        unwait();
      }, { udid } );  
    }
    shakeBtn.onclick = function( event ) {
      wait();
      req( 'POST', '/device/shake', function() {
        unwait();
      }, { udid } );  
    }*/
    ccBtn.onclick = function( event ) {
      sendCFRequest("showControlCenter",{});
    }
    atBtn.onclick = function( event ) {
      sendCFRequest("toggleAssistiveTouch",{});
    }
    hardPress.onclick = function( event ) {
      if( mode != 'hard' ) {
        hardPress.setAttribute( "class", 'iconify iconfiy-mdi mActive' );
        //longPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive');
        //vectorBtn.setAttribute( "class", "iconify iconify-mdi mInactive");
        mode = 'hard';
      } else {
        hardPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive' );
        mode = 'normal';
      }
    }
    /*vectorBtn.onclick = function( event ) {
      if( mode != 'vector' ) {
        hardPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive' );
        longPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive');
        vectorBtn.setAttribute( "class", "iconify iconify-mdi mActive");
        mode = 'vector';
      } else {
        vectorBtn.setAttribute( "class", 'iconify iconfiy-mdi mInactive' );
        mode = 'normal';
      }
    }*/
    if( ties["hardpress"] ) {
      var det = ties["hardpress"];
      hardPress.onmouseover = det.mouseover;
      hardPress.onmouseout = det.mouseout;
    }
    /*longPress.onclick = function( event ) {
      if( mode != 'long' ) {
        longPress.setAttribute( "class", 'iconify iconfiy-mdi mActive' );
        hardPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive' );
        //vectorBtn.setAttribute( "class", "iconify iconify-mdi mInactive");
        mode = 'long';
      } else {
        longPress.setAttribute( "class", 'iconify iconfiy-mdi mInactive' );
        mode = 'normal';
      }
    }*/
    shutdown.onclick = function( event ) {
      var ok = confirm("This will shutdown/reset the device provider. Are you sure?");
      if( ok ) {
        videoStop();
        if( videoSocket ) videoSocket.close();
        doShutdown();
      }
    }
    /*if( ties["longpress"] ) {
      var det = ties["longpress"];
      longPress.onmouseover = det.mouseover;
      longPress.onmouseout = det.mouseout;
    }*/
    
    ta.onmousedown = function( event ) {
      mouseDownDate = new Date();
      if( mode == 'hard' ){
          sendTapOrClickCFRequest(canvas, event, "tapFirm");
      }
      else if( mode == 'vector' ){
          sendTapOrClickCFRequest(canvas, event, "mouseDown");
      }
      else{
          mouseDownEvent = event ; //pos1 = pos;
      }
    }
    
    ta.onmouseup = function( event ) {
      let prevMouseDownEvent = mouseDownEvent;
      let prevMouseDownDate = mouseDownDate;

      mouseDownEvent = null;
      mouseDownDate = 0;

      if( mode == 'vector' ) {
          sendTapOrClickCFRequest( canvas, event, "mouseUp" );
          return;
      }
      if( !prevMouseDownDate ) { //mouseUp is meaningless unless corresponding mouseDown was on the canvas
          console.log("Cannot swipe from offscreen onto the screen");
          return;
      }
      if( mode != 'normal' && mode != "long" ) {
          return; //handled elsewhere as a click/tap
      }

      //swipe or long press
      let mouseUpDate = new Date();
      let msDiff = mouseUpDate - prevMouseDownDate;
      let sDiff = msDiff / 1000;
      sDiff = Math.floor( sDiff * 100 ) / 100; // .00 resolution
      
      if( mode == 'long' ) {
          sendTapOrClickCFRequest(canvas, prevMouseDownEvent , "tap", { "duration":sDiff }); //aka longPress
          return;
      }
      
      const [x1,y1] = getEventCoordinatesOnDevice(canvas, prevMouseDownEvent);
      const [x2,y2] = getEventCoordinatesOnDevice(canvas, event);
      const dx = Math.abs( x2 - x1 );
      const dy = Math.abs( y2 - y1 );

      if( dx  >= 40 || dy >= 40 ) { //TODO: twiddle 
        sendCFRequest("swipe", {
            path:[
                {x:x1,y:y1},
                {x:x2,y:y2,offset:sDiff},
            ]
        });
//        sendCFRequest("swipe", {
//            x1: x1,
//            y1: y1,
//            x2: x2,
//            y2: y2,
//            duration:sDiff
//        });
      } else if( sDiff > 0.2 ) {
          sendTapOrClickCFRequest(canvas, prevMouseDownEvent, "tap", { "duration":sDiff }); //aka longPress
      }
      else {  //didn't take that long and barely moved.  
          //If >=2 , this was a double-tap, triple tap, etc...
          //Without this check, the sequence is click1, click2, doubleClick
          //With the check, click doubleClick. TODO: handle tripleclick?
          if(event.detail == 1){ 
              sendTapOrClickCFRequest (canvas, event, "tap");
          }
      }
    }
    
    ta.ondblclick = function( event ) {
        sendTapOrClickCFRequest(canvas, event, "doubleTap");
    }
    
//    ta.onchange = function() {
    ta.oninput = function(event) {
        if(event.isComposing){
            return;
        }
        var text = ta.value;
        if(!text){
            return true;
        }  
        sendText(text);
        console.log(text);
        ta.value = "";
return true;
    }
    
    ta.onkeydown = function( event ) {
        if(event.isComposing){ //IME input (Japanese, etc)
            return;
        }
        if(specialKeys[event.code]){
            sendCFRequest("typeSpecialKey",{key:event.code});
        }
    }
    
    ta.onkeypress = function( event ) {
//Maybe?
//      if( capture2[ key ] ) {
//        event.preventDefault();
//      } else console.log( "key2 " + key );
    }
    
    ta.onpaste = function(event) {
      var text = "";
      if( event.clipboardData && event.clipboardData.getData ) {
        text = event.clipboardData.getData('text/plain');
      }
      if( text == "" ) return false;
      sendText( text );
      return false;
    }
    
    var wsprot = ( document.location.protocol == 'https:' ) ? "wss" : "ws";
 
    var recvUrl = wsprot+"://"+document.location.host+"/device/webSocket?udid={{ html .udid }}&rid={{ html .rid }}";
    commandSocket = new WebSocket( recvUrl );
    commandSocket.onmessage = function( event ) {
        var data = event.data;
        if( typeof data === 'string' ) {
            var message = JSON.parse (data); 
            if(message.type!="notice"){ //only messages currently are notices and acknowledgements for sent requests
                unwait();
            }
            else{
                if(message.status=="ORIENTATION_CHANGED"){
                    //console.log( data );
                    var o = message.value;
                    setOrientation( o );
                }
                //TODO: should we let the server ping us?
                //this is a placeholder, currently message.action reflects our original action
                //so when we send a "ping" we get back a "ping" with a value of "pong" 
                //Maybe that should change.  Should probably have a protocol for the server
                //pinging us...
                else if(response.status=="PING"){
                    //Unimplemented, untested (server not currently sending pings)
                    sendCFRequest("pong",{})
                }
            }
        }
    }
    
    var url = wsprot+"://"+document.location.host+"/device/imgStream?udid={{ html .udid }}&rid={{ html .rid }}";
    videoSocket = new WebSocket( url );
    videoSocket.onopen = function( event ) {
        console.log("Websocket open");
    }
    videoSocket.onclose = function( event ) {
        console.log("Websocket closed");
        videoSocket = null;
    }
    videoSocket.onmessage = function( event ) {
        if( event.data instanceof Blob ) {
          var recvTime = new Date().getTime();
          var image = new Image();
          var url;
          image.onload = function() {
            URL.revokeObjectURL( url );
            ctx.drawImage(image, 0, 0, Math.floor(displayWid)+1, Math.floor(displayHeg) );
          };
          image.onerror = function( e ) {
            console.log('Error during loading image:', e);
          }
          var blob = event.data;
          var imgData = blob.slice( 0, -100, "image/jpeg" );
          blob.slice( -100, blob.size, "" ).text().then( serverTimeStr => {
              //console.log( "serverTimeStr " + serverTimeStr );
              var serverTime = parseInt( serverTimeStr );
              var diff = recvTime - serverTime;
              if( diff < 0 ) diff = 0;
              //console.log( recvTime + " - " + serverTime + " = " + diff );
              
              //var bpms = (blob.size-100) / diff;
              //var bps = bpms * 1000;
              //console.log( "bps " + bps );
              sizes.push( blob.size );
              times.push( diff );
              if( sizes.length == 5 ) {
                  var totSize = 0;
                  var totTime = 0;
                  for( var i=0;i<5;i++ ) {
                      totSize += sizes[i];
                      totTime += times[i];
                  }
                  var bps = Math.floor( totSize / totTime * 1000 );
                  if( bps > 10000000 ) {
                      bps = 10000000;
                  }
                  //console.log("bps " + bps);
                  sizes = [];
                  times = [];
                  var avgFrame = Math.floor( totSize / 5 );
                  videoSocket.send( "{\"bps\":\"" + bps + "\",\"avgFrame\":\"" + avgFrame + "\"}" );
              }
          } );
          
          url = URL.createObjectURL( blob );
          image.src = url;
        }
        else {
            var data = event.data;
            if( typeof data === 'string' ) {
                var recvTime = new Date().getTime();
                var l1 = data[0];
                if( l1 >= '0' && l1 <= '9' ) {
                    var serverTime = parseInt( data );
                    var diff = recvTime - serverTime;
                    //console.log( "latency:" + diff );
                }
                else if( l1 == '{' ) {
                    var json = JSON.parse( data );
                    var type = json.type;
                    if( type ) {
                        if( type == 'kick' ) {
                            alert("You have been kicked");
                            document.location.href = "/";
                        }
                        if( type == 'sync' ) {
                            var serverTime = json.serverTime;
                            //console.log( "serverTime is " + serverTime );
                            var ourTime = Date.now();//new Date().getTime();
                            //console.log( "ourTime is " + ourTime );
                            
                            var diff = ourTime - serverTime;
                            
                            videoSocket.send( "{\"clientTime\":\"" + ourTime + "\",\"sentTime\":\"" + serverTime + "\"}" );
                            
                            //console.log( "latency + time offset = " + diff );
                        }
                    }
                } else if( data == "ping" ) {
                    console.log("ping");
                } else {
                    var parts = data.split(',');
                    if( parts[0] == 'sync' ) {
                        var serverTime = parts[1];
                        var ourTime = Date.now();//new Date().getTime();
                        var diff = ourTime - serverTime;
                            
                        videoSocket.send( "{\"clientTime\":\"" + ourTime + "\",\"sentTime\":\"" + serverTime + "\"}" );
                        
                        console.log( "latency + time offset = " + diff );
                    }
                }
            }
            //console.log( event.data );
        }
    }
    videoSocket.onerror = function( event ) {
        console.log( "Error: ", event.data );
    }
    if( idleTimeout ) {
      setInterval( function() {
        idleSeconds += 3;
        if( idleSeconds > idleTimeout ) {
          if( videoSocket ) videoSocket.close();
          navigator.sendBeacon( "/device/videoStop?udid="+udid+"&rid="+rid, "" );
          alert("Inactivity timeout");
          document.location.href = '/';
        }
      }, 3000 );
      window.onmousemove = function() {
        idleSeconds = 0;
      }
    }
  });
</script>
</head>

<body>
    <div id="main" class="main">
        <div>
            <table style="margin:auto; position: relative;"><tr>
                <td valign="top">
                    <div style="display: inline-block">
                        <a href='/'><i id='back' class="iconify" data-icon="mdi-arrow-left-bold"></i></a>
                    </div>
                </td>
                <td style="position:relative" id="mid">
                    <!--<i id="loading" style="vertical-align: top; position: absolute; left:100px; top:100px; font-size:100px;" class="m-spinner--swirl"></i>-->
                    <textarea id="ta"></textarea>
                    <canvas id="canvas" width="375" height="667" style="position:absolute; top:0px; left:0px;"></canvas><br>
                    <div style="position: absolute; width:375px; font-size: 32px" id="under">
                        <center>
                            <i id="home" class="iconify" data-icon="mdi-home"></i>
                            <i id="hardPress" class="iconify" data-icon="mdi-anvil"></i>
                            <!--<i id="longPress" class="iconify" data-icon="mdi-alarm-multiple"></i>-->
                            <!--<i id="taskBtn" class="iconify" data-icon="mdi-content-duplicate"></i>
                            <i id="shakeBtn" class="iconify" data-icon="mdi-cards-outline"></i>-->
                            <i id="ccBtn" class="iconify" data-icon="mdi-view-dashboard-outline"></i>
                            <i id="atBtn" class="iconify" data-icon="mdi-circle-box"></i>
                            <!--<i id="vectorBtn" class="iconify" data-icon="mdi-vector-polyline"></i>-->
                        </i>
                    </div>
                </td>
                <td valign="top" style="padding: 15px">
                    <table cellpadding=10 cellspacing=0>
                        <tr>
                            <td>Name</td>
                            <td id="d_name"></td>
                        </tr>
                        <tr>
                            <td>Model</td>
                            <td id="d_model"></td>
                        </tr>
                        <tr>
                            <td><nobr>iOS Version</nobr></td>
                            <td id="d_iosversion"></td>
                        </tr>
                        <tr>
                            <td><nobr>UDID</nobr></td>
                            <td id="d_udid"></td>
                        </tr>
                        <tr><td colspan=2 id="notes"></td></tr>
                        <tr><td colspan=2>
                          <i id='shutdown' class="iconify" data-icon="mdi-bomb"></i>
                        </tr></tr>
                        <tr>
                          <td colspan=2>
                            <i id="waiter" style="vertical-align: top" class="hidden m-spinner--swirl"></i>
                          </td>
                        </td>
                    </table>
                </td>
            </tr></table>
        </div>
    </div>
</body>
</html>